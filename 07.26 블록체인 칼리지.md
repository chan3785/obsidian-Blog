
### 날짜 : 2024-07-26 09:20

### 주제: 

---
### 메모: 
#### ERC20
approve 함수는 balance 보다 높은 값을 해 줘도 상관이 없다.
allowance는 transferFrom 함수를 트래킹 해주는 함수. 트랜스퍼 프롬을 쓰면 점점 줄어든다
approve 함수는 allowance를 초기화 시켜주는 함수

#### ERC721
approveforall은 토큰 수가 증가함에 따라 증가하는 연산량 때문에 가스비를 최적화 하려고 만든 함수다.
컨트랙트랑 eoa랑 같은 주소를 가지면 컨트랙트 먼저로 약속
safe가 붙은 건 검사를 해서 가스비가 더 많이 나간다
여기는 컴파일이 안되고 로컬 변수도 16개로 제한한다
전치연산과 후치연산에 따른 가스비가 다르다. 전치연산이 더 싸다.
이더리움이 비싸져서 가스비 최적화가 발전

external은 외부에서만
public은 내외부에서 모두 접근 가능
view는 상태변수 값을 변경할 수 없고 조회만
virtual은 overriding이 가능하게 하는 함수
memory , storage , calldata

storage는 이더리움 데이터. 외부에서 보면 모두가 다 똑같다.
memory는 휘발성 RAM
calldata는 동적인 할당이 많다.
memory나 calldata가 더 싸다

decimal이 18인 건 10^18 이 1이다.
그렇게 하면 부동소수점 에러 (정확도 이슈 등)을 개선할 수 있다.

private, internal, immutable 이 접근이 더 빠르다

이벤트 변수가 4개 이상이면 컴파일이 안됨
4개 안에서 잘 해야 한다.

솔리디티 컴파일러마다 컴파일 해주는 바이트 코드들이 다르다

unchecked -> 오버플로우 언더플로우가 일어나지 않으니까 가스비를 아낄 수 있다.


using 라이브러리 이름 for 데이터 타입
String 라이브러리를 uint256에 연결을 하면 
스트링 라이브러리에 있는 toString 함수를 uint256타입 변수에 바로 ㅏ용할 수 있다.

NFT는 1명한테만 approve를 할 수 있다.
balance는 컬렉션 수를 의미

padding 을 하면 0으로 밀어버리거나 안하거나

솔리디티는 함수 이름을 같게 할 수 있다.
솔리디티 컴파일러는 함수를 이름으로 구분하지 않음.
해시값을 함수 셀렉터로 사용하므로 컴파일 하는 순간 어차피 완전히 다른 함수이다.

hardhat.config.ts

여기서 니모닉, 인퓨라 api 검사
chain id으로 저장
chainConfig에서 rpc

hardhatuserconfig

--verify를 하면 deploy하면서 컨트랙트에 대한 정보를 올릴 수 있다.

하드햇, 파운드리
하드햇 - typescript
파운드리 - solidity
파일 투 파일 인터랙션도 가능
러스트 기반

결국은 둘 다 알아야 한다
요즘은 파운드리가 좀 더 우세하다

하드햇이 타입스크립트라 커리어적으로 봤을 땐 하드햇이 좀 더 굿

잘하는 애들의 코드를 계속 보면 익숙해질 거다
잘하는 애들이 코드를 다 공개를 한다
처음은 보면 정신병 걸릴 텐데
계속 보고 몇달동안 보니까 이해가 될 때가 온다
본인이 고민해서 풀어내는 시간이 필요한 것 같다 그 경험이 큰 자산이 될 거다

잘하는 팀 추천
유니스왑, aav 아베, 컴파운드, 오픈씨, 원 인치(얘는 어셈블리어가 많아서 이건 좀 투마치), beefy yeild aggregator

유니스왑 v2, v3
코드를 보고 분석하는 방법

디파이 라마에서 디파이 들어가면 프로토콜 순위를 보여준다.
오히려 무지성으로 다가가야 한다
공부에 왕도는 없다
효율을 생각해서 늦게 시작하는 것보다 지금 당장 보고 코드 패턴에 익숙해지는 게 더 빠르고 중요하다

디파이라마는 한 예시다

서양인이 아닌 이상 전통 금융공부보다는
동양인으로서 내러티브를 만들기보다 

### 출처(참고문헌)
-

### 연결문서
-