
### 날짜 : 2024-07-09 17:18

### 주제: #마스터링이더리움 #트랜잭션 #6장

---
### 메모: 
## 6장. 트랜잭션
트랜잭션(TX)란? 
-> 외부소유계정(EOA)에 의해 서명된 메시지. 
이더리움 네트워크에 의해 전송되고 이더리움 블록체인에 기록됨.
=> 데이터!

트랜잭션은 
- 이더리움의 상태를 변화 시킴!
- 컨트랙트를 실행 시킴!
월드 컴퓨터의 유일한 입력

#### 트랜잭션 구조
트랜잭션은 생성이 될 때 직렬화(serialize)됨.
-> 일렬로 나열된 데이터들의 필드 길이로 변환. (일반적으로 필드 구분자나 필드 라벨이 존재하지 않음)

직렬화 된 TX을 수신하는 client와 application은 자체 내부 데이터 메모리에 트랜잭션을 저장한다.

네트워크에 전송되는 트랜잭션과 client 메모리에 저장되는 트랜잭션은 서로 다를 수 있다.

1. **논스**
	발신 계정(EOA)에 의해 발행됨. 성공적으로 트랜잭션을 보낼 때마다 값이 1씩 증가. (트랜잭션의 고유성 보장)
2. **가스 가격**
	보내는 사람이 지급하는 가스의 가격. 단위는 wei.
3. **가스 한도**
	이 트랜잭션 실행(EVM)을 위해 구입할 가스의 최대량. 컨트랙트의 재귀 호출 등 Out Of Gas OOG 에러가 발생할 수 있음.
4. **수신자**
	목적지의 이더리움 주소.
5. **값**
	목적지에 보낼 이더의 양.
6. **데이터**
	크기가 변할 수 있는 바이너리 필드. 페이로드라고 하는 핵심적인 실제 데이터.
7. **v, r, s**
	발신자가 개인키로 ECDSA 디지털 서명하는 것의 세 가지 구성요소.

네트워크로 전송되는 트랜잭션의 표준은 위의 7가지 정보이다. 그 외에 메타데이터를 포함시킬 수 있다. (또 다른 논스, 블록번호, 트랜잭션 ID 등등)
#### 트랜잭션 논스
논스란? 
=> 해당 주소에서 보낸 트랜잭션 건수
또는 CA에서 만든 컨트랙트 생성 건수와 동일한 스칼라 값

논스는 발신자 (발신주소)의 속성(특징)이다. 
따라서 발신 주소의 컨텍스트 안에서만 의미를 가진다. 
그러면 발신자 계정에 저장되어서 계산 되느냐? Nope
해당 발신주소 (발신자 계정)에서 확인된 트랜잭션 건수를 세어서 dynamic 하게 계산.

트랜잭션을 생성하고 서명하면 nonce 값이 증가하는 것이 아니라 
생성하고 서명할 때 nonce 값을 계산해서 데이터 필드에 입력한다.

*논스가 중요한 이유*
이더리움 네트워크는 논스에 따라 트랜잭션의 순서 결정 및 고유성 보장.
예를 들어 논스가 2인 트랜잭션을 전송한 다음
논스가 4인 트랜잭션을 전송하면, 2번 째 트랜잭션은 누락된 트랜잭션이 나타날 때까지 멤풀로 들어가 대기한다. 논스가 3인 트랜잭션이 나타나면 3인 트랜잭션이 먼저 처리되고 그 다음 4인 트랜잭션이 처리된다.

=> 누락된 트랜잭션은 단순히 지연되었고, 논스가 4인 트랜잭션은 순서에 맞지 않게 수신되었다고 가정
#### 트랜잭션 가스
가스 = 이더리움의 연료
가스를 사용해 트랜잭션이 사용할 수 있는 자원의 양을 제한.
예를 들어, 트랜잭션이 발생시킨 연산 (컨트랙트 사용 등) 가스 한도 이상을 사용하게 되면 트랜잭션 취소.

튜링 완전 계산 모델은 DoS 공격이나 실수로 자원을 소모하게 되는 것에 취약함.
=> 정지 문제 (halting problem) 때문에

따라서 가스를 통해 미터링을 함으로써 방지.

$\ast$가스는 이더와 다름!!
이더 가격의 변동성으로부터 시스템 보호, 가스가 사용되는 자원 (계산, 메모리 및 저장)의 비용 사이의 민감한 비율을 관리하기 위해서
의도적으로 가스와 이더를 분리시킴.

가스를 이더로 구매한다고 해서 같다라는 개념이 아니다.
##### gasPrice
gasPrice 조절 가능!
높을 수록 더 빨리 컨펌될 확률 $\Uparrow$ 
$\Rightarrow$ 가스비로 보상을 주기 때문에 더 높은 gasPrice를 블록에 포함시키려는 경향성이 있음

가스비 (gas Fee) = 가스 가격 (gasPrice) x 가스 양 (gasAmount)

단순 EOA to EOA 이더 지급의 경우,
가스 양 21000으로 고정.
##### gasLimit
EOA to CA
CA to CA 등등은
가스 양 계산 필요.
추정 가능, 정확하게는 불가.

여러 요인으로 예상치 못하게 가스 비용이 증가할 수 있음.
만약 gas Fee가 gas Limit을 초과하면 트랜잭션은 취소된다.

gas Limit은 사용자가 이만큼 줄 수 있어! 라는 의미
이만큼 줄 테니 한번 일 해 봐! 근데 예산 넘어가면 모두 모가지인거야 알지?
예산과 같은 느낌

예산을 정해주면 트랜잭션 처리 evm 작동에 사용
이후에 컨펌이 되면 실제로 사용된 값 만큼만 계정에서 빠져나감.
만약 작동 중에 정해준 예산을 초과하거나,
정해준 예산만큼 계정에 돈이 없으면 트랜잭션이 취소됨.

#### 트랜잭션 수신자
##### to Field
20바이트 이더리움 주소.
EOA 또는 CA의 주소일 수 있다.

이더리움은 to 필드를 검증하지 않음!
모든 20바이트 값은 유효한 것으로 간주하기 때문에 주소를 잘못 입력하면 전송된 이더는 영원히 사용할 수 없게 됨.

주소에 대한 유효성 검사는 사용자 인터페이스 수준에서 수행되어야 함!
왜냐면, 이더리움은 그 주소가 공개키(개인키)에서 올바르게 파생 되었는지 확인할 수 있는 방법이 없다.

일부러 이더를 burning 시키려고 없는 주소로 보낼 수도 있기는 하다.

#### 트랜잭션 값과 데이터
트랜잭션의 페이로드 (주요 데이터)는 value, data 필드에 포함됨.
트랜잭션은 아래 4가지 경우 모두 유효함.

| value | data |       종류        |
| :---: | :--: | :-------------: |
|   O   |  X   |  지급 (payment)   |
|   X   |  O   | 호출 (invocation) |
|   O   |  O   |     지급, 호출      |
|   X   |  X   |      가스낭비       |
##### EOA 및 컨트랙트에 값 전달
값(value)가 포함되어 구성된 트랜잭션은 지급(payment)과 동일.
이런 트랜잭션은 목적지 주소가 트랜잭션인지 여부에 따라 다르게 작동한다.

###### EOA 주소 또는 컨트랙트로 표시되지 않은 주소의 경우,
이더리움 상태 변경에 기록되며 주소 잔액에 보낸 값을 추가.

*"이전에 주소가 표시되지 않은 경우, 클라이언트 내부 상태 표현에 추가되고 잔액은 지급 금액으로 초기화된다."*

이더리움은 EOA와 CA라고 부르는 계정으로 구성되어 있다.
여기서 EOA는 개인키를 가지고 생성할 수 있다.

계정을 생성한 직후에는 이더리움의 전역 상태 트리에 정보가 존재하지 않는다.
처음 트랜잭션을 생성 또는 수신했을 때 이더리움 전역 상태 트리에 추가된다.

트랜잭션이 없는 계정은 그저 사용자의 키 저장소에 개인키 공개키 쌍으로 존재할 뿐이다.

###### 목적지 주소가 컨트랙트인 경우,
EVM이 컨트랙트를 실행하고 트랜잭션의 데이터 페이로드에 지정된 함수를 호출하려고 시도한다. 
트랜잭션에 데이터가 없다면 **폴백(fall back)** 함수를 호출.
폴백 함수가 payable로 선언되어 있으면, 이더를 수신 가능하고, 폴백 함수 내에 추가적인 함수를 실행할 수 있음.

폴백 함수가 없으면
트랜잭션의 효과는 지갑에 지급하는 것과 마찬가지이므로
컨트랙트의 잔액만 늘림.

컨트랙트는 내부 로직으로 입금을 거부할 수도 있다.

함수가 예외없이 성공적으로 끝나면 컨트랙트의 상태가 업데이트 된다.

##### EOA 또는 컨트랙트에 데이터 페이로드 전달
트랜잭션에 data가 포함되어 있으면 목적지 주소는 컨트랙트 주소일 가능성이 크다. 

완전히 유효한 데이터 페이로드를 EOA로 보낼 수 없다는 뜻은 아님!
그러나 이런 경우엔 데이터 해석이 EOA에 접근하는 데 사용하는 지갑에 달려있다.

보통 그런 경우엔 이더리움 프로토콜에서 EOA로 전송되는 data 값을 무시한다.
대부분의 지갑 또한 트랜잭션에서 수신된 모든 데이터를 무시한다.

트랜잭션이 데이터를 컨트랙트 주소로 전달했다면,컨
EVM은 그것을 컨트랙트 호출 (contract invocation)으로 해석한다.
컨트랙트는 이 데이트를 함수 호출 (function invacation)로 사용하고
명명된 함수, 인코딩된 인수를 전달한다.

ABI 호환 컨트랙트 (모든 컨트랙트)로 전송되는 데이터 페이로드는 다음 항목을 16진수로 직렬화 한 인코딩이다.

1. 함수 선택기(function selector)
2. 함수 인수(function argument)

#### 특별 트랜잭션: 컨트랙트 생성
이것은 이름 때문에 헷갈릴 수 있지만 그냥 컨트랙트 배포를 의미한다.

컨트랙트 배포 트랜잭션은 **제로 어드레스**라는 특수 대상 주소로 전송된다.
to 필드에 0x0 주소를 포함한다.
=> 0x0을 나타내는 주소는 EOA 나 CA를 나타내지 않는다.
#### 디지털 서명
##### 트랜잭션 서명 실습
트랜잭션 발신자는 이더리움에서 트랜잭션을 발생하기 위해 다음 과정을 거쳐야 한다.
1. nonce, gasPrice, gasLimit, to, value, data, chainID, 0, 0 9개 필드를 가지는 트랜잭션 데이터 구조를 만든다.
2. RLP로 인코딩된 트랜잭션 데이터 구조의 직렬화된 메시지를 생성한다.
3. 이 시리얼라이즈된 메시지의 Keccak-256 해시를 계산한다.
4. 원래 EOA의 개인키로 해시에 서명하여 ECDSA 서명을 계산한다.
5. ECDSA 서명의 계산된 v,r,s 값을 트랜잭션에 추가한다.
#### 서명 접두어 값(v) 및 공개키 복구
#### 서명 및 전송 분리(오프라인 서명)
#### 트랜잭션 전파
이더리움은 플러드 라우팅 (flood routing) 프로토콜을 사용한다.
###### 플러드 라우팅 프로토콜이란?
1. 메시지 생성, 전송
	네트워크에서 메시지가 생성되면 이 메시지를 자신과 연결된 모든 이웃노드에 전송한다.
2. 메시지 전파
	메시지를 받은 각 이웃노드는 자신을 제외한 모든 이웃노드에 다시 전송된다.
	이 과정은 모든 노드에 메시지가 도달할 때까지 반복된다.
3. 중복 메시지 처리
	메시지 전파 과정에서 메시지가 중복으로 수신될 수 있다. 이를 방지하기 위해 각 노드는 수신한 메시지의 ID를 저장하고 중복이 되는 메시지는 무시한다.

장점
	단순함: 구현이 매우 간단함.
	신뢰성: 모든 경로로 메시지를 수신하므로 특정 경로가 실패해도 다른 경로로 전달될 가능성이 높음.
단점
	네트워크 부하: 모든 메시지가 네트워크의 모든 노드에 전달되므로 네트워크 트래픽이 매우 증가할 수 있음.
	중복 메시지: 쓸데없이 중복되어 네트워크 자원이 낭비됨.
	확장성 문제: 네트워크의 크기가 커질수록 위의 문제가 더욱 심각해짐.

사용자가 생성하고 개인키로 서명한 트랜잭션은 이더리움 클라이언트로 전달되고 이더리움 클라이언트들이 전파를 시작한다.
각 노드가 처음 트랜잭션을 수신하면 그걸 해싱을 해서 저장을 해두고 같은 해시의 메시지를 받으면 무시하면서 모든 노드에 전파될 때까지 반복한다.


#### 블록체인에 기록하기
PoW,PoS와 같은 방법으로 트랜잭션이 블록에 포함되면 이더리움 블록체인에 기록이 된다.
블록에 트랜잭션이 포함되면 계정의 잔액을 수정하거나
내부 상태를 변경하는 컨트랙트를 호출해 트랜잭션은 이더리움 싱글톤 상태를 수정한다.

#### 다중 서명 트랜잭션
#### 결론
### 출처(참고문헌)
-

### 연결문서
-